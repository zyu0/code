# 二叉树

每个节点都有两个指针，即每个节点有俩个儿子

 度为2的树

![image-20210213161135533](assets/image-20210213161135533.png)

## 二叉树种类

![image-20210213161525401](assets/image-20210213161525401.png)

## 重要性质

![image-20210213161711474](assets/image-20210213161711474.png)
$$
求边数：n_0+n_1+n_2-1=0*n_0+1*n_1+2*n_2(012是贡献度)
$$

## 二叉树的抽象数据类型定义

![image-20210213164053259](assets/image-20210213164053259.png)

## 存储结构

### 顺序存储

![image-20210213164913550](assets/image-20210213164913550.png)

![image-20210213165011612](assets/image-20210213165011612.png)

### 链表存储

![image-20210213165236725](assets/image-20210213165236725.png)

## 遍历

递归

### 先序遍历

![image-20210213170222138](assets/image-20210213170222138.png)

![image-20210213172822223](assets/image-20210213172822223.png)

```C
// 先序遍历
//a. 遇到一个节点，访问它，然后把它压栈，并去遍历它的左子树；
//b. 当左子树遍历结束后，从栈顶弹出该节点并将其指向右儿子，继续a步骤；
//c. 当所有节点访问完即最后访问的树节点为空且栈空时，停止。
void PreOrderTraversal(BinTree BT)
{
    BinTree T = BT;
    Stack S = CreatStack(MAX_SIZE);    //创建并初始化堆栈S
    while(T || !IsEmpty(S))
    {
        while(T)        //一直向左并将沿途节点访问（打印）后压入堆栈 
        {
            printf("%d\n", T->Data);
            Push(S, T);
            T = T->Left;
        }
        if (!IsEmpty(S))
        {
            T = Pop(S);    //节点弹出堆栈
            T = T->Right;  //转向右子树
        }
    }
}
```

### 中序遍历

![image-20210213170331615](assets/image-20210213170331615.png)

![image-20210213171711379](assets/image-20210213171711379.png)

![image-20210213171815053](assets/image-20210213171815053.png)

### 后序遍历

![image-20210213171008636](assets/image-20210213171008636.png)

![image-20210213171327631](assets/image-20210213171327631.png)



递归实现是堆栈，所以二叉树遍历用堆栈可实现非递归算法

```C
//后序遍历
// 对于一个节点而言，要实现访问顺序为左儿子-右儿子-根节点，可以利用后进先出的栈，在节点不为空的前提下，依次将根节点，右儿子，左儿子压栈
// 区别在于压栈顺序不同
void PostOrderTraversal(BinTree BT)
{
    BinTree T = BT;
    Stack S1 = CreatStack(MAX_SIZE);    //创建并初始化堆栈S1
    Stack S2 = CreatStack(MAX_SIZE);    //创建并初始化堆栈S2   
    while(T || !IsEmpty(S1))
    {
        while(T)        //一直向右并将沿途节点访问（压入S2）后压入堆栈S1 
        {
            Push(S2, T);
            Push(S1, T);
            T = T->Right;
        }
        if (!IsEmpty(S1))
        {
            T = Pop(S1);    //节点弹出堆栈
            T = T->Left;  //转向左子树
        }
    }
    while(!IsEmpty(S2))    //访问（打印）S2中元素
    {
        T = Pop(S2);
        printf("%d\n", T->Data);
    }          
}
```



### 层序遍历

二叉树遍历本质就是怎么把二维结构变成一维线性序列，不同的方法产生不同的一维序列

![image-20210213191604055](assets/image-20210213191604055.png)

![image-20210213192037744](assets/image-20210213192037744.png)

从上往下一层一层访问

![image-20210213192349553](assets/image-20210213192349553.png)



## 应用

![image-20210213193032586](assets/image-20210213193032586.png)

![image-20210213193042200](assets/image-20210213193042200.png)

![image-20210213193442781](assets/image-20210213193442781.png)

中缀表达式并不准确，看意思是对括号中优先级运算不准，需要输出左边添加左括号，输出右边添加右括号

![image-20210213194017116](assets/image-20210213194017116.png)

![image-20210213194905305](assets/image-20210213194905305.png)

![image-20210213195142555](assets/image-20210213195142555.png)

## 二叉搜索树

![image-20210213203203926](assets/image-20210213203203926.png)

### 二叉搜索树操作的特别函数

![image-20210213205833237](assets/image-20210213205833237.png)

编译角度尾递归都可以用循环表示

![image-20210213213754038](assets/image-20210213213754038.png)

![image-20210213213801772](assets/image-20210213213801772.png)

![image-20210213213810094](assets/image-20210213213810094.png)

### 查找最大和最小元素

![image-20210213214323912](assets/image-20210213214323912.png)

![image-20210213214448197](assets/image-20210213214448197.png)

### 二叉搜索树的插入

插入节点的复杂度和树的高度有关，O(log~2~n)，插入删除的复杂度都是树的高度

![image-20210214002540947](assets/image-20210214002540947.png)

![image-20210214002552107](assets/image-20210214002552107.png)

![image-20210214002654750](assets/image-20210214002654750.png)

### 二叉搜索树的删除

![image-20210214004327652](assets/image-20210214004327652.png)

![image-20210214004340778](assets/image-20210214004340778.png)

![1](assets/1.gif)

左子树的最大值和右子树的最小值一定不是有两个儿子的节点，因为各自在最左边和最右边，要么没有儿子，要么只有一个儿子

## 平衡二叉树

也是一个搜索树，AVL树

![image-20210214024054879](assets/image-20210214024054879.png)

### 平衡因子

![image-20210214024403377](assets/image-20210214024403377.png)

![image-20210214030303749](assets/image-20210214030303749.png)

![image-20210214030313077](assets/image-20210214030313077.png)

### 调整

插入删除时怎么做平衡

调整后保证还是一个搜索树

#### RR旋转

![image-20210214030937461](assets/image-20210214030937461.png)

![image-20210214031138122](assets/image-20210214031138122.png)

#### LL旋转

下面直接被破坏者Mar，间接被破坏者May，只要直接被破坏者平衡了，间接被破坏者就平衡了

![image-20210214031346624](assets/image-20210214031346624.png)

#### LR旋转

![image-20210214031804170](assets/image-20210214031804170.png)

#### RL旋转

![image-20210214032142483](assets/image-20210214032142483.png)

调整后，可能树结构不动，但平衡因子还是要动的







