## 链表存储

链表不再需要对数组进行大规模的迁移

![image-20210120231129850](assets/image-20210120231129850.png)

每个节点都包含两个量


### 求表长

![image-20210120231615285](assets/image-20210120231615285.png)

上图时间复杂度是O(n)，

7*p存储了第一个元素的地址

### 查找

![image-20210120232544104](assets/image-20210120232544104.png)

 ### 插入

![image-20210125223426708](assets/image-20210125223426708.png) ![image-20210125225744625](assets/image-20210125225744625.png)

返回的是新链表的头指针

![image-20210125230015844](assets/image-20210125230015844.png)

### 删除

![image-20210212153752998](assets/image-20210212153752998.png)

![image-20210212153806889](assets/image-20210212153806889.png)

 删除就是用指针指向节点后，释放它就删除了，但要将前一个节点指向后一个节点

### 多重链表

![image-20210212155925278](assets/image-20210212155925278.png)

![image-20210212160435253](assets/image-20210212160435253.png)

### 十字链表

4行5列7个非零项

![image-20210212161128613](assets/image-20210212161128613.png)

> 每个Head节点的Down域是左面的，Right是右面的，当然中间的叫MId。
>
> 这是我们会发现在每一个Head行节点的Right总是指向每一行的Term节点，这个时候Down没有利用。
>
> 同理，每一个Head列节点总是指向每一列的Term节点，这时候RIght域没有使用。
>
> 所以说我们可以利用这些没有使用的资源，整合起来重新利用，所以==**第i行的head和第i列的head实际上是同一个结点**==

利用都有down和right指针，所以将其中间union成一个域，复用空间

![image-20210212161700398](assets/image-20210212161700398.png)