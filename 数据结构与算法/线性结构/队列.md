# 队列

![image-20210212184026548](assets/image-20210212184026548.png)

先进先出表

## 队列的抽象数据类型描述

![image-20210212184118612](assets/image-20210212184118612.png)

## 队列的顺序存储实现

![image-20210212184338946](assets/image-20210212184338946.png)

![image-20210212184401349](assets/image-20210212184401349.png)

==此时Front= =Rear，队列为空==

Front没有删除队首则值一直会保持-1，每删除一个则Front向后移一位，但加满后Rear就填不进去了，则把值填入前面删除的位置，引出顺环队列



![image-20210212185204828](assets/image-20210212185204828.png)

队列大小为N，装载元素情况有N+1种情况，则n种状态区分n+1种矛盾

![image-20210212192326228](assets/image-20210212192326228.png)

- Size记录当前插入元素个数，插入+1.删除-1，看Size值为0或N来判断堆栈空满

- tag插入1删除0，记录最后一次操作的情况

- ==不放满，一般使用第二种不放满==

==都是用余数来定位值的位置==

![image-20210212193324449](assets/image-20210212193324449.png)

![image-20210212193333713](assets/image-20210212193333713.png)

在不放满的做法下，Front == Rear则队列为空

## 队列的链式存储实现

![image-20210212195348572](assets/image-20210212195348572.png)

**链表存储下，Front == Rear则队列只有一个元素，这是因为存储方式不同，做法不同导致的不同处**

![image-20210212195831932](assets/image-20210212195831932.png)

## 多项式加法运算

![image-20210212203601870](assets/image-20210212203601870.png)

![image-20210212205444180](assets/image-20210212205444180.png)

![image-20210212205429643](assets/image-20210212205429643.png)

![image-20210212210451206](assets/image-20210212210451206.png)

代码前面为方便运算创建的临时节点在运算完成后要释放，所以代码最后做了释放和令front指向多项式第一个非零项 

![image-20210212211924720](assets/image-20210212211924720.png)