# 堆栈

一种特殊的线性表

一种管理机制。把调用之前的变量状态和准备返回地址保留起来，这是一系列的执行和恢复过程，这样一种能够保存变量和返回地址的数据结构组织方式，按顺序的存储，在按倒过来顺序的返回，这样一种机制就是堆栈

## 应用

函数调用及递归实现

表达式求值

深度优先搜索

回溯算法

![image-20210212170016305](assets/image-20210212170016305.png)

![image-20210212170224739](assets/image-20210212170224739.png)

==先放进去的数后拿出来用，后放进去的数先拿出来，这就是堆栈==

![image-20210212170414167](assets/image-20210212170414167.png)

![image-20210212171938172](assets/image-20210212171938172.png)

## 堆栈的抽象数据类型描述

![image-20210212172041891](assets/image-20210212172041891.png)

![image-20210212172158188](assets/image-20210212172158188.png)

![image-20210212172223043](assets/image-20210212172223043.png)

![image-20210212172613453](assets/image-20210212172613453.png)

## 栈的顺序存储实现

### 入栈

![image-20210212172951067](assets/image-20210212172951067.png)

push时item放到top+1的位置，所以代码中先++，再赋值

### 出栈

![image-20210212173007105](assets/image-20210212173007105.png)

先抛出top值，再 - -

### 数组实现堆栈

![image-20210212173916029](assets/image-20210212173916029.png)

入栈出栈代码

![image-20210212174734662](assets/image-20210212174734662.png)

### 链表实现堆栈

top一定在链表头左边

定义了data域和Next域

==注意插入删除在栈顶，而栈顶在S节点后面==

![image-20210212180032030](assets/image-20210212180032030.png)

Push

不需要判别是否堆栈满了，是不断的申请节点插入的

![image-20210212180144695](assets/image-20210212180144695.png)

Pop

- 需要判断是否空

- 删除节点需要释放空间，但这就需要将节点赋值给一个变量

![image-20210212180642580](assets/image-20210212180642580.png)

## 堆栈应用：表达式求值

![image-20210212180736131](assets/image-20210212180736131.png)

![image-20210212181712047](assets/image-20210212181712047.png)



同一优先级看从左到右

![image-20210212181328177](assets/image-20210212181328177.png)

![image-20210212180947678](assets/image-20210212180947678.png)

![image-20210212181336427](assets/image-20210212181336427.png)

### 中缀表达式如何转换为后缀表达式

![image-20210212181540070](assets/image-20210212181540070.png)

![image-20210212181759165](assets/image-20210212181759165.png)

